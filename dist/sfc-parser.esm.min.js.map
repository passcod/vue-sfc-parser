{"version":3,"sources":["../sfc-parser.mjs"],"names":[],"mappings":"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","file":"sfc-parser.esm.min.js","sourcesContent":["/**\n * Parses a Vue-style Single File Component in a limited fashion for further\n * post-processing, with no dependencies, suitable for use in a Service Worker\n * or other such constrained environment.\n *\n * Parses only the top-level tags and provides their content as strings. Does\n * not prescribe any set of top-level tags, it will just parse everything. Also\n * supports HTML comments. Has some support for attributes on top-level tags,\n * such as for `<style scoped>` and `<script type=\"text/typescript\">`. Supports\n * nested <template> tags (it will leave interior ones as string content but it\n * internally keeps track for proper parsing).\n *\n * Does not support the string `</script>` inside a script tag, and similarly\n * for other tags. Just break it up e.g. `\"<\" + \"/script>\"` if you need to.\n *\n * @param str {string} source of the SFC to parse\n * @returns {Object[]} array of `{ tag: 'root level tag name', content: 'content', [attrs: { name: 'value' }] }`\n * @license Apache-2.0 OR MIT\n */\nexport default function parseSfc(str) {\n  const COMMENT = Symbol('comment');\n  const tags = [];\n\n  let partial = '', tag = '', attrs = {}, attr = null, content = '', depth = 0;\n\n  for (const char of str) {\n    // console.error('--(p,t,a,a,c,d,l)--', partial || null, tag || null, attrs, attr, content || null, depth, tags.length);\n\n    if (tag == COMMENT) {\n      if (char == '-') {\n        partial += char;\n      } else if (char == '>' && partial == '--') {\n        partial = '';\n        tag = '';\n        depth -= 1;\n      } else {\n        partial = '';\n      }\n\n      continue;\n    } else if (!tag) {\n      if (!partial) {\n        if (/\\s/.test(char)) continue;\n        if (char == '<') {\n          partial = '<';\n          continue;\n        }\n\n        throw new Error(`Unexpected '${char}', expected whitespace or '<'.`);\n      } else {\n        if (attr) {\n          if (!attr.n) {\n            if (/[a-z0-9-]/i.test(char)) {\n              attr.p += char;\n              continue;\n            }\n\n            if (char == '=') {\n              attr.n = attr.p;\n              attr.p = '';\n              continue;\n            }\n\n            if (/\\s/.test(char)) {\n              if (!attr.p) continue;\n              attrs[attr.p] = attr.p;\n              attr.p = '';\n              continue;\n            }\n\n            if (char == '>') {\n              if (attr.p) {\n                attrs[attr.p] = attr.p;\n              }\n              attr = null;\n              tag = partial.slice(1);\n              partial = '';\n              depth += 1;\n              continue;\n            }\n\n            throw new Error(`Unexpected '${char}', expected whitespace, attribute name, or '>'.`);\n          } else {\n            if (!attr.p) {\n              if (char == '>') throw new Error(`Unexpected '>', expected attribute value.`);\n              if (/\\s/.test(char)) continue;\n\n              attr.p += char;\n              continue;\n            }\n\n            if (\n              (attr.p.startsWith('\"') && char == '\"') ||\n              (attr.p.startsWith('\\'') && char == '\\'')\n            ) {\n              if (attr.p.endsWith('\\\\')) {\n                attr.p.pop();\n                attr.p.push(char);\n                continue;\n              }\n\n              attrs[attr.n] = attr.p.slice(1);\n              attr = null;\n              continue;\n            }\n\n            if (char == '>') {\n              if (attr.p.startsWith('\"') || attr.p.startsWith('\\''))\n                throw new Error(`Unexpected end of attribute, expected '${attr.p[0]}' terminator.`);\n\n              attrs[attr.n] = attr.p;\n              attr = null;\n              tag = partial.slice(1);\n              partial = '';\n              depth += 1;\n              continue;\n            }\n\n            attr.p += char;\n            continue;\n          }\n        } else {\n          if (/[a-z0-9-!]/i.test(char)) {\n            partial += char;\n            continue;\n          }\n\n          if (char == '>') {\n            tag = partial.slice(1);\n            partial = '';\n            depth += 1;\n            continue;\n          }\n\n          if (/\\s/.test(char)) {\n            if (partial == '<!--') {\n              tag = COMMENT;\n              partial = '';\n              depth += 1;\n              continue;\n            }\n\n            // attr [p]artial, [n]ame\n            attr = { p: '', n: '' };\n            continue;\n          }\n\n          throw new Error(`Unexpected '${char}', expected tag name or '>'.`);\n        }\n      }\n    } else {\n      if (partial) {\n        if (char == '>') {\n          if (partial.startsWith('</') && partial.slice(2) == tag) {\n            depth -= 1;\n            if (depth == 0) {\n              const newtag = { tag, content };\n              if (Object.entries(attrs).length) newtag.attrs = attrs;\n              tags.push(newtag);\n              tag = '';\n              partial = '';\n              attrs = {};\n              content = '';\n              continue;\n            }\n          } else if (partial.slice(1).split(/\\s/, 2)[0] == tag) {\n            depth += 1;\n            content += partial + char;\n            partial = '';\n            continue;\n          }\n\n          content += partial + char;\n          partial = '';\n          continue;\n        }\n\n        partial += char;\n      } else {\n        if (char == '<') {\n          partial = char;\n          continue;\n        }\n\n        content += char;\n      }\n    }\n  }\n\n  if (tag || partial || attr) {\n    throw new Error('Unexpected end of file.');\n  }\n\n  return tags;\n}\n"]}